/**
 * 项目名称：RapidWeb快速开发平台基础框架
 * 版权申明：RapidWeb项目组，未经许可不得在任何软件中以任何形式使用全部或部分代码，不得更改本项目的代码。
 * 文件名称：FileUtil.java
 * 创建时间：2009-8-30-上午02:26:33
 * 创建用户：chiyucheng(chis123@qq.com)
 * 文件描述：
 * 修改记录：
 *   
 */
package com.rapidweb2.common.util;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.rapidweb2.common.exception.Asserts;
import com.rapidweb2.common.exception.CommonException;
import com.rapidweb2.common.exception.UncheckedException;

/**
 * 文件与文件夹辅助类
 * 
 * @author chis
 * 
 */
public final class FilesUtil {
	private static Logger	log	= LoggerFactory.getLogger(FilesUtil.class);

	/**
	 * 关闭所有可关闭的对象
	 * @param obj
	 */
	public static void close( Closeable obj ){
		try {
			obj.close();
		} catch(IOException e) {
		}
	}
	
	/**
	 * 判断文件的编码方式
	 * 
	 * @param file
	 * @param defEncoding
	 * @return
	 */
	public static String adjustEncoding(File file, String defEncoding) {
		InputStream is = null;
		String encoding = defEncoding;

		try {
			is = new FileInputStream(file);
		} catch(FileNotFoundException e) {
			Asserts.illegalArgument("要解析的模版文件%s不存在", file.getAbsolutePath());
		}
		try {
			encoding = adjustEncoding(is, defEncoding);
		} finally {
			try {
				is.close();
			} catch(Throwable e1) {}
		}

		return encoding;
	}

	/**
	 * 自动识别文件的编码
	 * 
	 * @param is
	 * @param defEncoding
	 * @return 文件编码类型
	 */
	public static String adjustEncoding(InputStream is, String defEncoding) {
		String encoding = defEncoding;
		int chk = 0;
		int count = 0;

		while(count < 4) {
			try {
				int c = is.read();
				if(c == -1) break;
				chk = (chk << 8) | c;
				count++;
			} catch(IOException e) {
				try {
					is.close();
				} catch(IOException e1) {}
				throw new UncheckedException("文件读出错");
			}
		}
		try {
			is.close();
		} catch(IOException e1) {}
		if(count >= 4) {
			switch(chk){
				case 0x00000FEFF:
					encoding = "UTF-32BE";
					break;
				case 0x0FFFE0000:
					encoding = "UTF-32LE";
					break;
				case 0x03c:
					encoding = "UTF-32BE";
					break;
				case 0x03c000000:
					encoding = "UTF-32LE";
					break;
				case 0x0003c003f:
					encoding = "UTF-16BE";
					break;
				case 0x03c003f00:
					encoding = "UTF-16LE";
					break;
				// case 0x03c3f786d :
				default:
					if((chk & 0x0ffff0000) == 0x0FEFF0000) encoding = "UTF-16BE";
					else if((chk & 0x0ffff0000) == 0x0fffe0000) encoding = "UTF-16LE";
					else if((chk & 0x0ffffff00) == 0x0EFBBBF00) encoding = "UTF-8";
			}
		}

		return encoding;
	}

	/**
	 * 从一个文本文件中读取文件
	 * 
	 * @param path
	 * @return
	 * @throws CommonException
	 */
	public static String readTextFile(String path) throws CommonException {
		char[] buffer = {};
		BufferedReader br = null;
		try {
			br = new BufferedReader(new FileReader(path));
			br.read(buffer);
		} catch(Exception e) {
			e.printStackTrace();
			throw new CommonException("模版文件读写错误", e);
		} finally {
			try {
				br.close();
			} catch(IOException e) {}
		}
		return String.copyValueOf(buffer);
	}

	/**
	 * 读取文本文件内容
	 * 
	 * @param filePathAndName 带有完整绝对路径的文件名
	 * @param encoding 文本文件打开的编码方式
	 * @return 返回文本文件的内容
	 */
	public static String readTxt(String filePathAndName, String encoding) throws IOException {
		encoding = encoding.trim();
		StringBuffer str = new StringBuffer("");
		String st = "";
		FileInputStream fs = new FileInputStream(filePathAndName);;
		try {
			InputStreamReader isr;
			if(encoding.equals("")) {
				isr = new InputStreamReader(fs);
			} else {
				isr = new InputStreamReader(fs, encoding);
			}
			BufferedReader br = new BufferedReader(isr);
			try {
				String data = "";
				while((data = br.readLine()) != null) {
					str.append(data + "\n");
				}
			} catch(Exception e) {
				str.append(e.toString());
			}
			st = str.toString();
		} catch(IOException es) {
			st = "";
		} finally {
			fs.close();
		}

		return st;
	}

	/**
	 * 复制单个文件
	 * 
	 * @param oldPathFile 准备复制的文件源
	 * @param newPathFile 拷贝到新绝对路径带文件名
	 * @return boolean: 是否有拷贝文件
	 */
	public static boolean copyFile(String oldPathFile, String newPathFile) throws CommonException {
		boolean copy = false;
		try {
			int bytesum = 0;
			int byteread = 0;
			File oldfile = new File(oldPathFile);
			if(oldfile.exists()) // 文件存在时
			{
				// 如果目标目录不存在则创建
				if(newPathFile.lastIndexOf("/") > 0) {
					String newPath = newPathFile.substring(0, newPathFile.lastIndexOf("/"));
					if(!StringUtil.isEmpty(newPath)) {
						File folder = new File(newPath);
						if(!folder.exists()) folder.mkdirs();
					}
				}

				InputStream inStream = new FileInputStream(oldPathFile); // 读入原文件
				FileOutputStream fs = new FileOutputStream(newPathFile);

				byte[] buffer = new byte[1024 * 5];
				while((byteread = inStream.read(buffer)) != -1) {
					bytesum += byteread; // 字节数 文件大小
					fs.write(buffer, 0, byteread);
				}
				inStream.close();
				fs.flush();
				fs.close();

				copy = true;
			}
		} catch(Exception e) {
			throw new CommonException("复制单个文件操作出错", e);
		}

		return copy;
	}

	/**
	 * 删除文件
	 * 
	 * @param filename
	 * @return
	 */
	public static boolean delFile(String filename) {
		boolean result = false;

		File file = new File(filename);
		if(file.exists()) {
			result = file.delete();
		}

		return result;
	}

	/**
	 * 新建目录
	 * 
	 * @param folderPath 目录
	 * @return
	 */
	public static boolean createFolder(String folderPath) throws CommonException {
		try {
			File myFilePath = new File(folderPath);
			if(!myFilePath.exists()) {
				myFilePath.mkdirs();
			}
		} catch(Exception e) {
			throw new CommonException("创建目录错误：" + e.getMessage());
		}
		return true;
	}

	/**
	 * 获取文件的创建时间 TODO: 问题：文件全路径不能含有空格
	 * 
	 * @param filename
	 * @return
	 */
	public synchronized static String getCreateTime(String filename) {
		String getTime = null;
		try {
			Process p = Runtime.getRuntime().exec("cmd /C dir " + filename + " /tc");

			InputStream is = p.getInputStream();
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			String result;

			while((result = br.readLine()) != null) {
				String[] str = result.split(" ");
				for(int i = str.length - 1; i >= 0; i--) {
					if(str[i].equals(filename.substring(filename.lastIndexOf("\\") + 1))) {
						getTime = str[0] + " " + str[2];
					}
				}
			}
			is.close();
		} catch(java.io.IOException e) {
			e.printStackTrace();
		}

		return getTime;
	}

	/**
	 * 扩展名文件过滤器
	 * 
	 * @author hunting
	 * 
	 */
	public static class FileExtFileFilter implements FileFilter {
		private String	ext;

		public FileExtFileFilter(String ext) {
			this.ext = ext;
		}

		public boolean accept(File pathname) {
			String filename = pathname.getName().toLowerCase();

			return (pathname.isFile() && filename.contains(ext)) ? true : false;
		}
	}

	/**
	 * 遍历目录，并取出所有的文件进行二次处理
	 * 
	 * @param picker
	 * @param paths
	 */
	public static void stepPaths(IFilePicker picker, String... paths) {
		for(String path : paths) {
			File p = new File(path);
			if(p.exists() && p.isDirectory()) stepPath(picker, p);
		}
	}

	/**
	 * 遍历目录，并取出所有的目录进行处理
	 * 
	 * @param picker
	 * @param dir
	 */
	public static void stepPath(IFilePicker picker, File dir) {
		if(!dir.isDirectory()) return;
		for(File f : dir.listFiles()) {
			if(f.isFile()) try {
				picker.pick(f);
			} catch(Throwable e) {
				log.warn("处理" + f.getName() + "文件错误！", e);
			}
			if(f.isDirectory()) stepPath(picker, f);
		}
	}

	/* 文件处理者，处理遍历到的文件 */
	public static interface IFilePicker {
		public void pick(File file);
	}

	// /**
	// * 获得文件编码字符集
	// * @param f
	// * @return
	// */
	// public static Charset getEncoding(File f){
	// CodepageDetectorProxy detector = CodepageDetectorProxy.getInstance();
	// detector.add(new ParsingDetector(false));
	// detector.add(JChardetFacade.getInstance());
	// detector.add(ASCIIDetector.getInstance());
	// detector.add(UnicodeDetector.getInstance());
	//		
	// try {
	// Charset charset = detector.detectCodepage(new FileInputStream(f),100);
	// return charset;
	// } catch (IllegalArgumentException e) {
	// e.printStackTrace();
	// } catch (FileNotFoundException e) {
	// e.printStackTrace();
	// } catch (IOException e) {
	// e.printStackTrace();
	// }
	//		
	// throw new RuntimeException("未知的文件编码");
	//
	// }

}