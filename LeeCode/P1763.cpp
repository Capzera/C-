/*
问题描述：最长美好字符串
当一个字符串 s?包含的每一种字母的大写和小写形式 同时?出现在 s?中，就称这个字符串?s?是 美好 字符串。
比方说，"abABB"?是美好字符串，因为?'A' 和?'a'?同时出现了，且?'B' 和?'b'?也同时出现了。
然而，"abA"?不是美好字符串因为?'b'?出现了，而?'B'?没有出现。
给你一个字符串?s?，请你返回?s?最长的?美好子字符串?。如果有多个答案，请你返回?最早?出现的一个。
如果不存在美好子字符串，请你返回一个空字符串。
示例 1：
输入：s = "YazaAay"
输出："aAa"
解释："aAa" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。
"aAa" 是最长的美好子字符串。
示例 2：
输入：s = "Bb"
输出："Bb"
解释："Bb" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。
示例 3：
输入：s = "c"
输出：""
解释：没有美好子字符串。
示例 4：
输入：s = "dDzeE"
输出："dD"
解释："dD" 和 "eE" 都是最长美好子字符串。
由于有多个美好子字符串，返回 "dD" ，因为它出现得最早。
提示：
1 <= s.length <= 100
s?只包含大写和小写英文字母。
*/
class Solution {
public:
    bool isnice(unordered_map<char,int> um)
    {
        for(auto m=um.begin();m!=um.end();m++)
        {
            if (m->first<91&&um.find(m->first+32)==um.end()) return false;//当前为大写字母
            if (m->first>96&&um.find(m->first-32)==um.end()) return false;//当前为小写字母
        }
        return true;
    }
    string longestNiceSubstring(string s) {
        int n=s.size(),i;
        string ans="";
        if (n==1) return ans;//只有1个字母肯定不完美
        for(int x=n;x>=2;x--)//x为窗口大小
        {
            unordered_map<char,int> um;
            for (i=0;i<x;i++) um[s[i]]++;//初始化窗口
            if (isnice(um))//初始窗口即所求
            {
                for(i=0;i<x;i++) ans+=s[i];
                return ans;
            }
            for (i=x;i<n;i++)//开始滑动
            {
                um[s[i]]++;
                if (um[s[i-x]]>1) um[s[i-x]]--;
                else um.erase(s[i-x]);//窗口更新
                if (isnice(um))//当前窗口即所求
                {
                    for(int j=i-x+1;j<=i;j++) ans+=s[j];//答案为当前窗口
                    return ans;
                } 
            }
        }
        return ans;
    }
};