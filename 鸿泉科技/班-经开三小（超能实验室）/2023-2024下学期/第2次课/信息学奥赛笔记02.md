# 信息学奥赛笔记02

DFS训练

## [U413822] 特殊的质数https://www.luogu.com.cn/problem/U413822?contestId=162503

## 题目描述

给定一个数`n`，请按**从小到大**的顺序输出长度为`n`的特殊的质数。

特殊的质数指的是，从右端删除若干个数后仍然是一个质数。

例如：`7331`就是一个特殊的质数，因为`7331`，`733`，`73`， `7`都是一个质数。

## 输入格式

一个正整数`n`。

## 输出格式

若干行，每一行是一个特殊的质数。

## 样例 #1

### 样例输入 #1

```
1
```

### 样例输出 #1

```
2
3
5
7
```

## 提示

对于$100\%$的数据，有$1 \leq n \leq 8$。



## 思路分析

> 什么是特殊的质数，这个质数删除右边的几位后它仍然是一个特殊的质数，换言之，一个长的特殊的质数是怎么来的？他是由一个先前的本身就是特殊的质数再补上一位数引出来的。
>
> 也就是说，先有`7`是质数，再有`73`是质数，然后是`733`，所以想要顺利做出这道题，我们需要逆转思维方式，反过来想，不应该去验证这个数是不是特殊的质数，而是应该反过来去看如何组成一个特殊的质数，这种需要我们逆向思考的题目在竞赛中是非常常见的，同学们需要对这种思维方式产生一种习惯。
>
> 那么我们再思考一下DFS的三个量：传入参数，终止条件，循环方式分别应该是什么呢？
>
> 传入参数：我们正在补第几位的数，因为题目要求我们输出n位的特殊质数，所以我们应该先考虑更短的特殊质数
>
> 终止条件，当已经补了n位数字时结束，满足题目要求
>
> 循环方式，从当前这一位数到下一位数，有多少种情况？可以补1-9这些数，这就是循环的范围。
>
> 当我们搞明白了DFS三要素后，代码就迎刃而解了。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long ans;
int n;
bool isPrime(long long x) {
	if (x == 1) return 0;
	if (x == 2 || x == 3) return 1;
	if (x % 6 != 1 && x % 6 != 5) return 0;
	long long n = sqrt(x);
	for (int i = 5; i <= n; i += 6) {
		if (x % i == 0 || (x % (i + 2)) == 0) return 0;
	}
	return 1;
}
void dfs(int idx) { // 传入参数：idx表示我们正在填第idx个数
	if (idx == n) { // 终止条件：当已经填写n个数后输出答案并return
		cout << ans << endl;
		return;
	}
	if (idx == 0) {
		ans = 2;
		dfs(1);
		ans = 0;
	}
	for (int i = 1; i <= 9; i++) { // 循环方式：从当前这一层到下一层的状态变化情况。
		long long nxt = ans * 10 + i;
		if (isPrime(nxt) == 0) continue;
		ans = nxt;
		dfs(idx + 1);
		ans /= 10;
	}
	
}
int main() {
	cin >> n;
	dfs(0);   //最一开始，我们从填了0个数开始执行。
	return 0;
}
```



## \[B3949][语言月赛 202403] 星云

## 题目背景

你看，那一抹云，衬着星星，多美啊！

## 题目描述

定义星云数为位数不大于 $n$ 且各数位之和不超过 $k$ 的正整数，给定 $n,k$，求星云数的个数。

## 输入格式

第一行输入两个整数 $n,k$。

## 输出格式

输出一行一个整数，表示答案。

## 样例 #1

### 样例输入 #1

```
3 2
```

### 样例输出 #1

```
9
```

## 提示

### 数据规模与约定

对于 $30\%$ 的数据，$n=1$。  
对于 $100\%$ 的数据，$1 \leq n \leq 7$，$1 \leq k \leq 100$。



## 思路分析

> 一眼数据范围，非常小，而且题目牵扯到了数的位数，可以用DFS写，我们可以从位数少的数，每次往后加位，来一直枚举到不超过n位数，接下来想DFS的三要素
>
> 传入参数：当前填写的数位，以及我们目前这些数的和是几
>
> 终止条件：最多放入n个数为止
>
> 循环方式：从当前这一位数到下一位数的变化途径，0-9，但是由于数的首位不能为0，所以需要单独处理一开始的情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, ans = 0;
void dfs(int i, int sum) {
	if (sum != 0) ans++; //排除0这种情况，只有在一开始为0的时候sum才是0，需要注意的细节是，我们需要在判断终止条件前就要让答案+1，否则正好第n个数的时候，会先return，不会影响答案。
	if (i == n) return;  //如果已经记录了n位数，return
	int st = 0; //用st来记录，我们应该从几开始枚举，如果是第一个数，那么st为1
	if (i == 0) st = 1;
	for (int j = st; j <= 9; j++) {
		if (sum + j > k) return;   //如果加上这个数j会导致和比k大，没有必要再做下去，直接return
		dfs(i + 1, sum + j);   //下一个数，并且和的记录状态为sum + j
	}
}
int main() {
	cin >> n >> k;
	dfs(0, 0);
	cout << ans << endl;
	return 0;
}
```

