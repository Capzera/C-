# 信息学奥赛笔记15



## [U396930] 涂色游戏 https://www.luogu.com.cn/problem/U396930?contestId=159138

## 题目描述

有一段长度为 $N$ 的纸条，纸条上从左到右有 $N$ 个空白格子，纸张质量很好，格子可被多次涂色。现在小鸿有一支画笔，准备对纸条做 $m$ 操作，每次操作为给定一个区间 $[L,R]$ ，对区间 $[L,R]$ 上的格子涂色，现要求你帮小鸿计算，当他做完这 $m$ 次操作后，每个格子被涂色的次数。

## 输入格式

第一行有两个整数，分别表示纸条的长度 $N$ 和操作的次数 $m$。

第二行开始，接下来 $m$ 行，每行两个整数 $L、R$，表示小鸿每次涂色的区间。

## 输出格式

一行，$N$ 个整数，表示这 $N$ 个格子被涂色的次数。

## 样例 #1

### 样例输入 #1

```
5 2
1 3
2 4
```

### 样例输出 #1

```
1 2 2 1 0
```

## 提示

**数据范围**

对于 $100\%$ 的数据，有$1\le N \le 10^6,1 \le m \le 10^6,1 \le L \le R \le N$。

> 对区间`[l, r]`每次询问加1，毫无疑问是差分数组的模板题。
>
> 直接套用差分数组模板即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n, m, l, r;
    cin >> n >> m;
    vector<long long> nums(n + 2);
    while (m--) {
        cin >> l >> r;
        nums[l]++, nums[r + 1]--;
    }
    for (int i = 1; i <= n; i++) {
        nums[i] += nums[i - 1];
        cout << nums[i] << " ";
    }
    return 0;
}
```



## [U396931]涂色游戏2 https://www.luogu.com.cn/problem/U396931?contestId=159138

## 题目描述

有一段长度为 $N$ 的纸条，纸条上从左到右有 $N$ 个空白格子，纸张质量很好，格子可被多次涂色。现在小鸿有一支画笔，准备对纸条做 $m$ 操作，每次操作为给定一个序号 $x$ ，对序号 $x$ 上的格子涂色，现要求你帮小鸿计算，当他做完这 $m$ 次操作后，对所有格子进行分组，涂色次数相同的格子分为一组（**不统计空白格子**），这些格子总共要被分为多少组。

## 输入格式

第一行有两个整数，分别表示纸条的长度 $N$ 和操作的次数 $m$。

第二行开始，接下来 $m$ 行，每行一个整数 $x$，表示小鸿每次涂色的格子序号。

## 输出格式

一个整数，表示格子被分为多少组。

## 样例 #1

### 样例输入 #1

```
5 2
1
2
```

### 样例输出 #1

```
1
```

## 提示

**数据范围**

对于 $100\%$ 的数据，有$1\le N \le 10^{18},1 \le m \le 10^6,1 \le x  \le N$。



> 这道题目参与到修改区间的范围高达$10^{18}$，所以用差分数组的话，无法开辟那么大的空间，那么取而代之的是，现在变成了单点修改而不是区间修改，我们可以使用更符合要求的map来做。

本题需要着重注意的是，map的遍历规则和迭代器的使用

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<long long, int> mp;
unordered_set<int> s;
long long n, m, x;
int main() {
   	cin >> n >> m;
   	while (m--) {
   		cin >> x;
   		mp[x]++;
	}
	for (auto it = mp.begin(); it != mp.end(); it++) { //map的遍历
		s.emplace(it->second); //将结果加入桶，这里也可以使用set。
	}
	cout << s.size() << endl;
    return 0;
}
```

