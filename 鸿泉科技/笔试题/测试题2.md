# <center> 信息学测试（J1）</center>

## **考试时间：2小时。**						

### **分值：**400分，共四道编程题，每道题100分

### **提交方式：**以“**姓名**”命名文件夹，此文件夹内必须包含每道题的源代码。源代码请按照题目当中规定的名字命名，最后将“姓名”命名的文件夹**压缩**并提交。超过提交截止时间后仍未提交的，按0分处理。





# [Problem A] 卡车（truck.cpp）

## 题目描述

$S$国的卡车有两个油箱，主油箱中有$a$加仑燃料，副油箱有$b$加仑燃料。

该卡车在一条笔直的马路上匀速行驶，每消耗$1$加仑燃料都可以行驶$xkm$，且每当主油箱消耗$k$加仑燃料时，如果副油箱有燃料，都将从副油箱转移$1$加仑燃料到主油箱。

求这辆卡车最大的行驶距离。

注意：从副油箱转移至主油箱并不是一个连续的的行为，这一事件在每消耗$k$加仑燃料时，突然且瞬间发生。

## 输入格式

一行四个整数，$a，b，x，k$，符合题目描述。

## 输出格式

一个整数，表示所求答案。

## 样例 #1

### 样例输入 #1

```
5 10 10 5
```

### 样例输出 #1

```
60
```

## 提示

对于$50\%$的数据，有$1 \leq a, b \leq 10^4$，$1 \leq k, x \leq 10^3$。

对于$100\%$的数据，有$1 \leq a, b \leq 10^9$，$1 \leq k, x \leq 10^9$。

样例解释：

用掉$5$加仑燃料时，副油箱向主油箱传递$1$加仑燃料，卡车共行驶$50km$，再次消耗$1$加仑燃料，卡车再行驶$10km$，共计$60km$。





# [Problem B] 能量牌 (card.cpp)

## 题目描述

小$A$和小$B$在玩一款特殊的游戏。这个游戏的规则如下，小$A$有$n$张卡牌，每张牌上有一个点数，表示卡牌的能量。

小$B$作为防守方，拿出了$m$张卡牌防守，每张卡牌拥有一个护盾量，当能量牌大于护盾量的时候，这张牌就会被击碎。

轮到小$A$操作了，假设他是一个绝顶聪明的人，请你帮助小$A$计算一下，这一回合内他最多可以击碎小$B$多少张卡牌。

## 输入格式

第一行$2$个整数$n，m$，表示小$A$派出进攻牌的数量和小$B$派出防守牌的数量。

第二行共$n$个整数，每个整数$a_i$表示小$A$第$i$张卡牌的能量。

第三行共$m$个整数，每个整数$b_i$表示小$B$第$i$张卡牌的护盾量。

## 输出格式

一行一个整数，表示小$A$最多能击碎小$B$多少张卡牌

## 样例 #1

### 样例输入 #1

```
4 3
1 5 4 3
2 6 3
```

### 样例输出 #1

```
2
```

## 提示

对于$30\%$的数据，有$1 \leq n，m \leq 10^3$， $1 \leq a_i，b_i \leq 10^3$。

对于$100\%$的数据，有$1 \leq n，m \leq 2 * 10^5$， $1 \leq a_i，b_i \leq 10^9$。

样例解释：

第$1$轮，小$A$用第$3$张牌击碎小$B$第$1$张牌，小$A$用第$4$张牌击碎小$B$第$3$张牌，最多可以击碎他两张牌。



# [Problem C] 消消乐 (digest.cpp)

## 题目描述

小$Y$最近在玩一款特殊的消消乐游戏，这个游戏是由若干个方块组成的，其中方块一共有`n`列，每一列的高度为$a_i$(高度可以为负），现在这个游戏有如下规则：

+ 选中所有方块的列数中高度最低的那一列（如果有多个高度相同且最低，任选一个）对所有的列都减去$a_i$个方块。
+ 被消除的那一列方块被清空，可以看成是被消除的那列方块将从数组中移除。
+ 如果只剩`1`列，将结束操作。

现在小$Y$有多次操作的机会，求小$Y$能使得若干次消除后，方块列中剩下的方块中，使得最矮的那一列方块最多。

## 输入格式

第一行一个正整数$n$，表示列数。

第二行$n$个正整数，表示每一列初始方块的高度。

## 输出格式

一个整数，表示消除后最大的最小高度。

## 样例 #1

### 样例输入 #1

```
3
-1 2 0
```

### 样例输出 #1

```
2
```

## 提示

对于$30\%$的数据，有 $1 \leq n \leq 1000, -10^6 \leq a_i \leq 10^6$，

对于$100\%$的数据，有$1 \leq n \leq 2 × 10^5, -10^9 \leq a_i \leq 10^9$。 	

### 样例解释 #1
> 一次都不消除的情况下，数组的最小值为`[-1]`，第一次选择最小的值为`-1`，将其消除后，数组变为`[3, 1]`，数组的最小值为`[1]`，再次选择数组的最小值`1`，将其消除后数组变为`[2]`，最小值为`[2]`。所以三次数组的最小值的最大值为`2`。



# [Problem D]最大01串奇数和（string.cpp）

## 题目描述

给定你两个`01字符串` `a, b`，它们代表着两个二进制的整数。现在你可以对每个字符串进行重新排列后对两个这两个二进制整数字符串进行求和，在和为一个**奇数**的情况下，输出最大可能的和。

`01字符串`指的是只包含字符`0`和字符`1`的字符串，且保证输入数据有解。

注意：你只能使用输入的两个字符串进行重排，不能对字符串整数补前导$0$或者删除前导$0$，例如：$001$可以重排为$010$，但是不能把它重排为$00010$。

## 输入格式

两行，每行一个字符串，仅包含'0'和'1'。

## 输出格式

一个字符串，表示答案。

## 样例 #1

### 样例输入 #1

```
1010
0100
```

### 样例输出 #1

```
10001
```

## 提示

设$l1，l2$为字符串$a，b$的长度。

对于$10\%$的数据，有$1 \leq l1, l2 \leq 10$。

对于$40\%$的数据，有$1 \leq l1，l2 \leq 10^4$。

对于$100\%$的数据，有$1 \leq l1， l2 \leq 2 * 10 ^5$。

对于额外$10\%$的数据：字符串$a，b$各只含有一个'1'。

对于额外$10\%$的数据：有$l1 = l2$。

对于额外$10\%$的数据，字符串$a, b$种含有的$1$均**不**大于字符串长度的一半。

保证字符串中仅含有'0'和'1'

样例解释：

第一个数重排为$1001$，第二个数重排为$1000$，结果为$10001$，是个奇数，可以证明，没有比$10001$更大的答案。