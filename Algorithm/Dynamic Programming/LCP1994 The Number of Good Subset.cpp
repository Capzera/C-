/*
问题描述：P1994
给你一个整数数组?nums?。如果?nums?的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为?好子集?。
比方说，如果?nums = [1, 2, 3, 4]?：
[2, 3]?，[1, 2, 3]?和?[1, 3]?是 好?子集，乘积分别为?6 = 2*3?，6 = 2*3?和?3 = 3?。
[1, 4] 和?[4]?不是 好?子集，因为乘积分别为?4 = 2*2 和?4 = 2*2?。
请你返回 nums?中不同的?好?子集的数目对?109 + 7?取余?的结果。
nums?中的 子集?是通过删除 nums?中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。
如果两个子集删除的下标不同，那么它们被视为不同的子集。
示例 1：
输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
示例 2：
输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
提示：
1 <= nums.length <= 105
1 <= nums[i] <= 30
*/
const long mod = 1e9+7;
class Solution {
public:
    long pow(long a, long e) {
        if(e == 0) return 1;
        if(e == 1) return a;
        long tmp = pow(a,e/2);
        return (e&1) ? ((tmp * tmp)%mod * a) % mod: (tmp * tmp) % mod;
    }
    int numberOfGoodSubsets(vector<int>& nums) {
        int cnt[31];
        memset(cnt, 0, sizeof(cnt));
        for(int e:nums)
            cnt[e]++;
        map<long,long> m;
        m[1] = pow(2, cnt[1]);
        for(int e:{2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}){
            for(auto &p:m) {
                if(gcd(p.first, e) == 1) {
                    m[p.first * e] = (m[p.first * e] + cnt[e]*p.second)  % mod;
                }
            }
        }
        int ans = -m[1];
        for(auto &p:m) {
            ans = (ans + p.second) % mod;
        }
        return ans;
    }
};