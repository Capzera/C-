/*
问题描述：P0076
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：
输入：s = "a", t = "a"
输出："a"
示例 3:
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
提示：
1 <= s.length, t.length <= 105
s 和 t 由英文字母组成
*/
class Solution {
public:
	unordered_map<char,int> um,win;
	bool check (){
		for (auto& p:um){
			if (win[p.first]<p.second) return false;
		}
		return true;
	}
    string minWindow(string s, string t) {

        int l=0,r=0,n=s.size(),minL=INT_MAX,L=-1;
        for (auto& i:t) um[i]++;
        while (r<n) {
			if(um.count(s[r])) win[s[r]]++;
            while(check()&&l<=r){
				if(r-l+1<minL){
					L=l;
                    minL=r-l+1;
				}
                if (um.find(s[l])!=um.end()) win[s[l]]--;
				l++;
            }
            r++;
		}
        return L<0? "":s.substr(L,minL);
    }
};